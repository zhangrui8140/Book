1.类加载过程
查找是否加载由下到上 加载由上到下

①Bootstrap ClassLoader

负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类

②Extension ClassLoader

负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包

③App ClassLoader

负责记载classpath中指定的jar包及目录中class

④Custom ClassLoader

属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader

2.java内存模型
JVM内存结构分为：
方法区（method），可通过-XX:PermSize和-XX:MaxPermSize来指定最小值和最大值。
栈内存（stack），
堆内存（heap）， 其大小可以通过-Xmx和-Xms来控制
本地方法栈（java中的jni调用）

3.垃圾回收机制
堆里聚集了所有由应用程序创建的对象，JVM也有对应的指令比如 new, newarray, anewarray和multianewarray，然并没有向 C++ 的 delete，free 等释放空间的指令，Java的所有释放都由 GC 来做，GC除了做回收内存之外，另外一个重要的工作就是内存的压缩，这个在其他的语言中也有类似的实现，相比 C++ 不仅好用，而且增加了安全性，当然她也有弊端，比如性能这个大问题。

何时会抛出OutOfMemoryException，并不是内存被耗空的时候才抛出
JVM98%的时间都花费在内存回收
每次回收的内存小于2%
  满足这两个条件将触发OutOfMemoryException，这将会留给系统一个微小的间隙以做一些Down之前的操作，比如手动打印Heap Dump。


-XX:+PrintGC 输出GC日志
-verbose:gc 示输出虚拟机中GC的详细情况
-XX:+PrintGCDetails 输出GC的详细日志
-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）
-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）
-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息
-Xloggc:../logs/gc.log 日志文件的输出路径

4.JVM内存回收
把对象分为
年青代(Young)、-Xmn设置  默认堆大小的1/15  minor gc  标记-清理算法
年老代(Tenured)、 Full GC -Xmx和-Xms  复制算法
持久代(Perm)  方法区  full GC  放着类、方法的定义，jvm Stack区域放着方法参数、局域变量等的引用
堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old)。新生代 ( Young ) 又被划分为三个区域：Eden、S0、S1。 这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。
Java 中的堆也是 GC 收集垃圾的主要区域。GC 分为两种：Minor GC、Full GC

-Xms	初始堆的分配大小，默认为物理内存的六十四分之一	
-Xmx	堆的最大分配大小（默认为物理内存的四分之一）	
-Xmn	新生代的大小

-Xms8m -Xmx8m -XX:+PrintGCDetails 
参数是一次设置最大分配8M，初始分配也是8M，并且打印GC的信息 

JVM有三种垃圾回收器，分别是throughput collector，用来做并行young generation回收，由参数-XX:+UseParallelGC启动；
concurrent low pause collector，用来做tenured generation并发回收，由参数-XX:+UseConcMarkSweepGC启动；incremental low pause collector，可以认为是默认的垃圾回收器。不建议直接使用某种垃圾回收器，最好让JVM自己决断，除非自己有足够的把握。


从最强到最弱，不同的引用（可到达性）级别反映了对象的生命周期。

l  Strong Ref(强引用)：通常我们编写的代码都是Strong Ref，于此对应的是强可达性，只有去掉强可达，对象才被回收。

l  Soft Ref(软引用)：对应软可达性，只要有足够的内存，就一直保持对象，直到发现内存吃紧且没有Strong Ref时才回收对象。一般可用来实现缓存，通过java.lang.ref.SoftReference类实现。

l  Weak Ref(弱引用)：比Soft Ref更弱，当发现不存在Strong Ref时，立刻回收对象而不必等到内存吃紧的时候。通过java.lang.ref.WeakReference和java.util.WeakHashMap类实现。

l  Phantom Ref(虚引用)：根本不会在内存中保持任何对象，你只能使用Phantom Ref本身。一般用于在进入finalize()方法后进行特殊的清理过程，通过java.lang.ref.PhantomReference实现。


5.Jvm区域总体分两类
heap区和非heap区。
heap区又分：Eden Space（伊甸园）、Survivor Space(幸存者区)、Tenured Gen（老年代-养老区）。 
非heap区又分：Code Cache(代码缓存区)、Perm Gen（永久代）、Jvm Stack(java虚拟机栈)、Local Method Statck(本地方法栈)。

6.工具使用
jps, jstack, jmap, jconsole, jinfo, jhat, javap，jprofiler
