JAVA 基础
1、List 和 Set 的区别
2、HashSet 是如何保证不重复的
3、HashMap 是线程安全的吗，为什么不是线程安全的（最好画图说明多线程环境下不安全）?
一旦形成环形数据结构，Node的next节点永远不为空，就会在获取Node时产生死循环
4、HashMap 的扩容过程
5、HashMap 1.7 与 1.8 的 区别，说明 1.8 做了哪些优化，如何优化的？
计算方式 原位置OR原位置+旧容量               hashcode
转移数据 尾插法 红黑树                       头插法 逆序 环形
插入与计算时机  扩容前插入后计算             扩容后插入 单独计算
6、final finally finalize
7、强引用 、软引用、 弱引用、虚引用
8、Java反射
9、Arrays.sort和Collections.sort实现原理解析
总结，插入排序，快速排序，归并排序三种排序的组合
至于大过INSERTION_SORT_THRESHOLD（47）的，用一种快速排序(双轴快排)的方法：
INSERTION_SORT_THRESHOLD为47，发现当要排序的个数小于47个时，采用插入排序
10、LinkedHashMap的应用
11、cloneable接口实现原理
12、异常分类以及处理机制
13、wait和sleep的区别
sleep()和wait()方法的最大区别是： 
　sleep()睡眠时，保持对象锁，仍然占有该锁； 
　而wait()睡眠时，释放对象锁。 
　但是wait()和sleep()都可以通过interrupt()方法打断线程的暂停状态，从而使线程立刻抛出InterruptedException（但不建议使用该方法）。
14、数组在内存中如何分配



Java 并发

1、synchronized 的实现原理以及锁优化？
2、volatile 的实现原理？
3、Java 的信号灯？
4、synchronized 在静态方法和普通方法的区别？
5、怎么实现所有线程在等待某个事件的发生才会去执行？
6、CAS？CAS 有什么缺陷，如何解决？
7、synchronized 和 lock 有什么区别？
8、Hashtable 是怎么加锁的 ？
9、HashMap 的并发问题？
10、ConcurrenHashMap 介绍？1.8 中为什么要用红黑树？
11、AQS
12、如何检测死锁？怎么预防死锁？
13、Java 内存模型？
14、如何保证多线程下 i++ 结果正确？
15、线程池的种类，区别和使用场景？
16、分析线程池的实现原理和线程的调度过程？
17、线程池如何调优，最大数目如何确认？
18、ThreadLocal原理，用的时候需要注意什么？
19、CountDownLatch 和 CyclicBarrier 的用法，以及相互之间的差别?
20、LockSupport工具
21、Condition接口及其实现原理
22、Fork/Join框架的理解
23、分段锁的原理,锁力度减小的思考
24、八种阻塞队列以及各个阻塞队列的特性