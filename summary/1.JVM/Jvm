---------------------------##JVM##--------------------------------
1.什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？
Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。 Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。

2.类加载机制 

双亲委派模型  请求委托给父加载器去完成，依次向上

1）Bootstrap ClassLoader：负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类
2）Extension ClassLoader：负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包
3）App ClassLoader：负责记载classpath中指定的jar包及目录中class

3.类的生命周期
加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象。

连接，连接又包含三块内容：验证、准备、初始化。
1）验证，文件格式、元数据、字节码、符号引用验证；
2）准备，为类的静态变量分配内存，并将其初始化为默认值；
3）解析，把类中的符号引用转换为直接引用

初始化，为类的静态变量赋予正确的初始值。

4.JIT即时编辑器
热点代码做编译，  采样、计数 确定是否为热点代码
非热点代码直接解析


5.JVM内存模型
Jvm区域总体分两类
heap区和非heap区。
heap区又分：Eden Space（伊甸园）、Survivor Space(幸存者区)、Tenured Gen（老年代-养老区）。 
非heap区又分：Code Cache(代码缓存区)、Perm Gen（永久代）、Jvm Stack(java虚拟机栈)、Local Method Statck(本地方法栈)。

方法区：存储已被虚拟机加载的类元数据信息(元空间)  类信息、常量、静态变量
		运行时常量, Class文件有一个常量池用来存放编译器生成的各种字面量和符号引用，这部分内容在类加载后存放到方法区的运行时常量池中。

VMStack：
1.各种基础数据类型（boolean、byte、char 、short、int、float、long、double ）；
2.方法的形式参数，方法调用完后从栈空间回收；
3.引用对象的地址，引用完后，栈空间地址立即被回收，堆空间等待GC。
       JVM的栈也属于线程私有的内存，用户可以设置大小，后面会讲到。对于异常，这块区域有两种情况：如果线程请求的栈深度大于JVM所允许的深度，将抛出StackOverflowError异常；如果JVM的栈可以动态扩展，但是在尝试扩展时无法申请到足够的内存则抛出OutOfMemoryError异常。


本地方法栈：本地方法栈则为虚拟机使用到的 Native 方法服务

堆：存放对象实例，几乎所有的对象实例都在这里分配内存

程序计数器：当前线程所执行的字节码的行号指示器   Native 方法，这个计数器的值则为 (Undefined)




6.JVM内存回收

把对象分为
年青代(Young)、-Xmn设置  默认堆大小的1/15  minor gc   复制算法
1个Eden区和2个Survivor区（分别叫From和To）,默认比例为8：1
(FROM TO 交替填充 直到填满Survivor半个区域)
经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。Eden区和Survivor区并不是按照1:1的比例来划分内存空间的，当Survivor空间不够用时，需要依赖老年代的空间来进行分配。


垃圾收集算法
GC最基础的算法有三种： 标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法。

标记 -清除算法，“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。

复制算法，“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。

标记-压缩算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

分代收集算法，“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。


年老代(Tenured)、 Full GC -Xmx和-Xms  标记-清理算法 
持久代(Perm)  方法区  full GC  放着类、方法的定义，jvm Stack区域放着方法参数、局域变量等的引用
堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old)。新生代 ( Young ) 又被划分为三个区域：Eden、S0、S1。 这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。
Java 中的堆也是 GC 收集垃圾的主要区域。GC 分为两种：Minor GC、Full GC

-Xms	初始堆的分配大小，默认为物理内存的六十四分之一	
-Xmx	堆的最大分配大小（默认为物理内存的四分之一）	
-Xmn	新生代的大小
-Xms / -Xmx — 堆的初始大小 / 堆的最大大小 
-Xmn — 堆中年轻代的大小 
-XX:-DisableExplicitGC — 让System.gc()不产生任何作用 
-XX:+PrintGCDetails — 打印GC的细节 
-XX:+PrintGCDateStamps — 打印GC操作的时间戳 
-XX:NewSize / XX:MaxNewSize — 设置新生代大小/新生代最大大小 
-XX:NewRatio — 可以设置老生代和新生代的比例 
-XX:PrintTenuringDistribution — 设置每次新生代GC后输出幸存者乐园中对象年龄的分布 
-XX:InitialTenuringThreshold / -XX:MaxTenuringThreshold：设置老年代阀值的初始值和最大值 -XX:TargetSurvivorRatio：设置幸存区的目标使用率
-XX:+PrintGC 输出GC日志
-verbose:gc 示输出虚拟机中GC的详细情况
-XX:+PrintGCDetails 输出GC的详细日志
-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）
-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）
-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息
-Xloggc:../logs/gc.log 日志文件的输出路径

-Xms8m -Xmx8m -XX:+PrintGCDetails 
参数是一次设置最大分配8M，初始分配也是8M，并且打印GC的信息 

JVM有三种垃圾回收器，
分别是throughput collector，用来做并行young generation回收，由参数-XX:+UseParallelGC启动；

concurrent low pause collector，用来做tenured generation并发回收，由参数-XX:+UseConcMarkSweepGC启动；

incremental low pause collector，可以认为是默认的垃圾回收器。不建议直接使用某种垃圾回收器，最好让JVM自己决断，除非自己有足够的把握。

Serial收集器，串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。
ParNew收集器，ParNew收集器其实就是Serial收集器的多线程版本。
Parallel收集器，Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。
Parallel Old 收集器，Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法
CMS收集器，CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。
G1收集器，G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征


从最强到最弱，不同的引用（可到达性）级别反映了对象的生命周期。

l  Strong Ref(强引用)：通常我们编写的代码都是Strong Ref，于此对应的是强可达性，只有去掉强可达，对象才被回收。

l  Soft Ref(软引用)：对应软可达性，只要有足够的内存，就一直保持对象，直到发现内存吃紧且没有Strong Ref时才回收对象。一般可用来实现缓存，通过java.lang.ref.SoftReference类实现。

l  Weak Ref(弱引用)：比Soft Ref更弱，当发现不存在Strong Ref时，立刻回收对象而不必等到内存吃紧的时候。通过java.lang.ref.WeakReference和java.util.WeakHashMap类实现。

l  Phantom Ref(虚引用)：根本不会在内存中保持任何对象，你只能使用Phantom Ref本身。一般用于在进入finalize()方法后进行特殊的清理过程，通过java.lang.ref.PhantomReference实现。


7.Java对象结构
Java对象由三个部分组成：对象头、实例数据、对齐填充。

对象头由两部分组成，第一部分存储对象自身的运行时数据：哈希码、GC分代年龄、锁标识状态、线程持有的锁、偏向线程ID（一般占32/64 bit）。第二部分是指针类型，指向对象的类元数据类型（即对象代表哪个类）。如果是数组对象，则对象头中还有一部分用来记录数组长度。

实例数据用来存储对象真正的有效信息（包括父类继承下来的和自己定义的）

对齐填充：JVM要求对象起始地址必须是8字节的整数倍（8字节对齐）



9.JVM面试
1.详细jvm内存模型 
虚拟机栈、堆、方法区、程序计数器、本地方法栈
2、讲讲什么情况下回出现内存溢出，内存泄漏？
对象是可达的(一直被引用)   

内存泄露导致堆栈内存不断增大，从而引发内存溢出。
大量的jar，class文件加载，装载类的空间不够，溢出
操作大量的对象导致堆内存空间已经用满了，溢出
nio直接操作内存，内存过大导致溢出

查看程序是否存在内存泄漏的问题
设置参数加大空间
代码中是否存在死循环或循环产生过多重复的对象实体、
查看是否使用了nio直接操作内存。


3、说说Java线程栈
JVM规范让每个Java线程拥有自己的独立的JVM栈，也就是Java方法的调用栈。
当方法调用的时候，会生成一个栈帧。栈帧是保存在虚拟机栈中的，栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息
线程运行过程中，只有一个栈帧是处于活跃状态，称为“当前活跃栈帧”，当前活动栈帧始终是虚拟机栈的栈顶元素。
通过jstack工具查看线程状态


4、JVM 年轻代到年老代的晋升过程的判断条件是什么呢？
部分对象会在From和To区域中复制来复制去,如此交换15次(由JVM参数MaxTenuringThreshold决定,这个参数默认是15),最终如果还是存活,就存入到老年代。
如果对象的大小大于Eden的二分之一会直接分配在old，如果old也分配不下，会做一次majorGC，如果小于eden的一半但是没有足够的空间，就进行minorgc也就是新生代GC。
minor gc后，survivor仍然放不下，则放到老年代
动态年龄判断 ，大于等于某个年龄的对象超过了survivor空间一半 ，大于等于某个年龄的对象直接进入老年代


5、JVM 出现 fullGC 很频繁，怎么去线上排查问题？
老年代的空间设置过小了
频繁创建了大对象(也有可能eden区设置过小)


6、类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？
安全性问题
在实际开发中，我们可以通过自定义ClassLoader，并重写父类的loadClass方法，

7、类的实例化顺序
1． 父类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行
2． 子类静态成员和静态初始化块 ，按在代码中出现的顺序依次执行
3． 父类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行
4． 父类构造方法
5． 子类实例成员和实例初始化块 ，按在代码中出现的顺序依次执行
6． 子类构造方法


8、JVM垃圾回收机制，何时触发MinorGC等操作
当young gen中的eden区分配满的时候触发MinorGC(新生代的空间不够放的时候).

9、JVM 中一次完整的 GC 流程（从 ygc 到 fgc）是怎样的
YGC ：对新生代堆进行gc。频率比较高，因为大部分对象的存活寿命较短，在新生代里被回收。性能耗费较小。
FGC ：全堆范围的gc。默认堆空间使用到达80%(可调整)的时候会触发fgc。以我们生产环境为例，一般比较少会触发fgc，有时10天或一周左右会有一次。

10.各种回收算法
标记-清除算法，“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。
复制算法，“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
标记-压缩算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存
分代收集算法，“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。



11、各种回收器，各自优缺点，重点CMS、G1
Serial收集器，串行收集器是最古老，最稳定以及效率高的收集器，但可能会产生较长的停顿，只使用一个线程去回收。
ParNew收集器，ParNew收集器其实就是Serial收集器的多线程版本。
Parallel收集器，Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。
Parallel Old收集器，Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程“标记－整理”算法
CMS收集器，CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它需要消耗额外的CPU和内存资源，在CPU和内存资源紧张，CPU较少时，会加重系统负担。CMS无法处理浮动垃圾。CMS的“标记-清除”算法，会导致大量空间碎片的产生。
G1收集器，G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征。



12、OOM错误，stackoverflow错误，permgen space错误

stackoverflow错误主要出现：

在虚拟机栈中(线程请求的栈深度大于虚拟机栈锁允许的最大深度)
permgen space错误(针对jdk之前1.7版本)：

大量加载class文件
常量池内存溢出

13. 自己编写各种outofmemory，stackoverflow程序
    HeapOutOfMemory
    Young OutOfMemory
    MethodArea OutOfMemory
    ConstantPool OutOfMemory
    DirectMemory OutOfMemory
    Stack OutOfMemory
    Stack OverFlow











