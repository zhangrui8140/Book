redis memcache ehcache
---------------------------------------
cdn缓存
广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对集中的地区或网络中，在用户访问网站时，利用全局负载技术将用户的访问指向距离最近的工作正常的缓存服务器上，由缓存服务器直接响应用户请求

主要缓存静态资源，例如图片，视频

---------------------------------------
反向代理缓存
反向代理位于应用服务器机房，处理所有对WEB服务器的请求。 如果用户请求的页面在代理服务器上有缓冲的话，代理服务器直接将缓冲内容发送给用户。如果没有缓冲则先向WEB服务器发出请求，取回数据，本地缓存后再发送给用户。通过降低向WEB服务器的请求数，从而降低了WEB服务器的负载。

一般只缓存体积较小静态文件资源，如css、js、图片
Nginx


---------------------------------------
本地应用缓存

缓存字典等常用数据

Ehcache是​​一种基于标准的开源缓存，可提高性能，卸载数据库并简化可伸缩性。 它是使用最广泛的基于Java的缓存，因为它功能强大，经过验证，功能齐全，并与其他流行的库和框架集成。Ehcache可以从进程内缓存扩展到使用TB级缓存的混合进程内/进程外部署

Guava Cache是Google开源的Java重用工具集库Guava里的一款缓存工具
---------------------------------------
分布式缓存
基本介绍
Memcached是一个高性能，分布式内存对象缓存系统，通过在内存里维护一个统一的巨大的hash表，它能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。简单的说就是将数据调用到内存中，然后从内存中读取，从而大大提高读取速度。

Question
------------------------------------
缓存与数据库双写不一致

最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern。
先更新数据库，然后再删除缓存。（删除 避免数据不经常访问 却需要不停更新  用到缓存才去算缓存）

删除缓存失败
解决思路：先删除缓存，再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。

思考:
1.本地队列  读取+缓存更新 放入队列（数据库操作队列） 

2..利用zookeeper 分布式协调 更新缓存和数据实现分布式（队列中） 
读取数据 注册zookeeper消息 一旦更新成功 读取

3.zookeeper分布式锁 缓存与数据库变更 事务
------------------------------------

缓存雪崩、

缓存雪崩的事前事中事后的解决方案如下。（缓存宕机 数据库压力过大奔溃 数据库处理后又一波请求来袭）
事前：redis 高可用，主从+哨兵，redis cluster，避免全盘崩溃。

事中：本地 ehcache 缓存 + hystrix 限流&降级，避免 MySQL 被打死。
限流组件，可以设置每秒的请求，有多少能通过组件，剩余的未通过的请求，怎么办？走降级！可以返回一些默认的值，或者友情提示，或者空白的值。（保证数据库可用）

事后：redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。

------------------------------------
缓存穿透
恶意跳过缓存 撞击数据库

解决方式很简单，每次系统 A 从数据库中只要没查到，就写一个空值到缓存里去，比如 set -999 UNKNOWN。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。

缓存击穿
缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。

解决方式也很简单，可以将热点数据设置为永远不过期；或者基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据。
------------------------------------
缓存并发竞争

redis 事务的 CAS 方案
WATCH  回滚机制

基于zookeeper的分布式锁

-------------------------------------
redis 和 memcached 有啥区别
redis 支持复杂的数据结构
redis 原生支持集群模式
性能对比
由于 redis 只使用单核，而 memcached 可以使用多核，所以平均每一个核上 redis 在存储小数据时比 memcached 性能更高。而在 100k 以上的数据中，memcached 性能要高于 redis。虽然 redis 最近也在存储大数据的性能上进行优化，但是比起 memcached，还是稍有逊色。

redis 的线程模型
socket io多路复用 


为啥 redis 单线程模型也能效率这么高？
纯内存操作。
核心是基于非阻塞的 IO 多路复用机制。
C 语言实现，一般来说，C 语言实现的程序“距离”操作系统更近，执行速度相对会更快。
单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题。
-------------------------------------

Redis
基本介绍
Redis是一个远程内存数据库（非关系型数据库），性能强劲，具有复制特性以及解决问题而生的独一无二的数据模型。它可以存储键值对与5种不同类型的值之间的映射，可以将存储在内存的键值对数据持久化到硬盘，可以使用复制特性来扩展读性能， Redis还可以使用客户端分片来扩展写性能。内置了 复制（replication），LUA脚本（Lua scripting），LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（high availability）。

redis 实现简单的高性能分页

redis 过期策略是：
定期删除（每隔 100ms 随机 抽取一些 key 来检查和删除的）
惰性删除（获取 key 的时候，如果此时 key 已经过期，就删除，不会返回任何东西
内存淘汰机制 
noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错，这个一般没人用吧，实在是太恶心了。
allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。
allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key，这个一般没人用吧，为啥要随机，肯定是把最近最少使用的 key 给干掉啊。
volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的 key（这个一般不太合适）。
volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。
volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 优先移除。

redis replication 的核心机制
用异步方式复制数据到 slave 节点 
开启 master node 的持久化
-------------------------------------